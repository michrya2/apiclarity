// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"errors"
	"net/url"
	golangswaggerpaths "path"

	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GetAPIEventsURL generates an URL for the get API events operation
type GetAPIEventsURL struct {
	BflaStatusIsNot               []string
	BflaStatusIs                  []string
	DestinationIPIsNot            []string
	DestinationIPIs               []string
	DestinationK8sObjectNameIsNot []string
	DestinationK8sObjectNameIs    []string
	DestinationPortIsNot          []string
	DestinationPortIs             []string
	EndTime                       strfmt.DateTime
	HasSpecDiffIs                 *bool
	MethodIs                      []string
	Page                          int64
	PageSize                      int64
	PathContains                  []string
	PathEnd                       *string
	PathIsNot                     []string
	PathIs                        []string
	PathStart                     *string
	ShowNonAPI                    bool
	SortDir                       *string
	SortKey                       string
	SourceIPIsNot                 []string
	SourceIPIs                    []string
	SourceK8sObjectNameIsNot      []string
	SourceK8sObjectNameIs         []string
	SpecDiffTypeIs                []string
	SpecContains                  []string
	SpecEnd                       *string
	SpecIsNot                     []string
	SpecIs                        []string
	SpecStart                     *string
	StartTime                     strfmt.DateTime
	StatusCodeGte                 *string
	StatusCodeIsNot               []string
	StatusCodeIs                  []string
	StatusCodeLte                 *string

	_basePath string
	// avoid unkeyed usage
	_ struct{}
}

// WithBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *GetAPIEventsURL) WithBasePath(bp string) *GetAPIEventsURL {
	o.SetBasePath(bp)
	return o
}

// SetBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *GetAPIEventsURL) SetBasePath(bp string) {
	o._basePath = bp
}

// Build a url path and query string
func (o *GetAPIEventsURL) Build() (*url.URL, error) {
	var _result url.URL

	var _path = "/apiEvents"

	_basePath := o._basePath
	if _basePath == "" {
		_basePath = "/api"
	}
	_result.Path = golangswaggerpaths.Join(_basePath, _path)

	qs := make(url.Values)

	var bflaStatusIsNotIR []string
	for _, bflaStatusIsNotI := range o.BflaStatusIsNot {
		bflaStatusIsNotIS := bflaStatusIsNotI
		if bflaStatusIsNotIS != "" {
			bflaStatusIsNotIR = append(bflaStatusIsNotIR, bflaStatusIsNotIS)
		}
	}

	bflaStatusIsNot := swag.JoinByFormat(bflaStatusIsNotIR, "")

	if len(bflaStatusIsNot) > 0 {
		qsv := bflaStatusIsNot[0]
		if qsv != "" {
			qs.Set("bflaStatus[isNot]", qsv)
		}
	}

	var bflaStatusIsIR []string
	for _, bflaStatusIsI := range o.BflaStatusIs {
		bflaStatusIsIS := bflaStatusIsI
		if bflaStatusIsIS != "" {
			bflaStatusIsIR = append(bflaStatusIsIR, bflaStatusIsIS)
		}
	}

	bflaStatusIs := swag.JoinByFormat(bflaStatusIsIR, "")

	if len(bflaStatusIs) > 0 {
		qsv := bflaStatusIs[0]
		if qsv != "" {
			qs.Set("bflaStatus[is]", qsv)
		}
	}

	var destinationIPIsNotIR []string
	for _, destinationIPIsNotI := range o.DestinationIPIsNot {
		destinationIPIsNotIS := destinationIPIsNotI
		if destinationIPIsNotIS != "" {
			destinationIPIsNotIR = append(destinationIPIsNotIR, destinationIPIsNotIS)
		}
	}

	destinationIPIsNot := swag.JoinByFormat(destinationIPIsNotIR, "")

	if len(destinationIPIsNot) > 0 {
		qsv := destinationIPIsNot[0]
		if qsv != "" {
			qs.Set("destinationIP[isNot]", qsv)
		}
	}

	var destinationIPIsIR []string
	for _, destinationIPIsI := range o.DestinationIPIs {
		destinationIPIsIS := destinationIPIsI
		if destinationIPIsIS != "" {
			destinationIPIsIR = append(destinationIPIsIR, destinationIPIsIS)
		}
	}

	destinationIPIs := swag.JoinByFormat(destinationIPIsIR, "")

	if len(destinationIPIs) > 0 {
		qsv := destinationIPIs[0]
		if qsv != "" {
			qs.Set("destinationIP[is]", qsv)
		}
	}

	var destinationK8sObjectNameIsNotIR []string
	for _, destinationK8sObjectNameIsNotI := range o.DestinationK8sObjectNameIsNot {
		destinationK8sObjectNameIsNotIS := destinationK8sObjectNameIsNotI
		if destinationK8sObjectNameIsNotIS != "" {
			destinationK8sObjectNameIsNotIR = append(destinationK8sObjectNameIsNotIR, destinationK8sObjectNameIsNotIS)
		}
	}

	destinationK8sObjectNameIsNot := swag.JoinByFormat(destinationK8sObjectNameIsNotIR, "")

	if len(destinationK8sObjectNameIsNot) > 0 {
		qsv := destinationK8sObjectNameIsNot[0]
		if qsv != "" {
			qs.Set("destinationK8sObject.name[isNot]", qsv)
		}
	}

	var destinationK8sObjectNameIsIR []string
	for _, destinationK8sObjectNameIsI := range o.DestinationK8sObjectNameIs {
		destinationK8sObjectNameIsIS := destinationK8sObjectNameIsI
		if destinationK8sObjectNameIsIS != "" {
			destinationK8sObjectNameIsIR = append(destinationK8sObjectNameIsIR, destinationK8sObjectNameIsIS)
		}
	}

	destinationK8sObjectNameIs := swag.JoinByFormat(destinationK8sObjectNameIsIR, "")

	if len(destinationK8sObjectNameIs) > 0 {
		qsv := destinationK8sObjectNameIs[0]
		if qsv != "" {
			qs.Set("destinationK8sObject.name[is]", qsv)
		}
	}

	var destinationPortIsNotIR []string
	for _, destinationPortIsNotI := range o.DestinationPortIsNot {
		destinationPortIsNotIS := destinationPortIsNotI
		if destinationPortIsNotIS != "" {
			destinationPortIsNotIR = append(destinationPortIsNotIR, destinationPortIsNotIS)
		}
	}

	destinationPortIsNot := swag.JoinByFormat(destinationPortIsNotIR, "")

	if len(destinationPortIsNot) > 0 {
		qsv := destinationPortIsNot[0]
		if qsv != "" {
			qs.Set("destinationPort[isNot]", qsv)
		}
	}

	var destinationPortIsIR []string
	for _, destinationPortIsI := range o.DestinationPortIs {
		destinationPortIsIS := destinationPortIsI
		if destinationPortIsIS != "" {
			destinationPortIsIR = append(destinationPortIsIR, destinationPortIsIS)
		}
	}

	destinationPortIs := swag.JoinByFormat(destinationPortIsIR, "")

	if len(destinationPortIs) > 0 {
		qsv := destinationPortIs[0]
		if qsv != "" {
			qs.Set("destinationPort[is]", qsv)
		}
	}

	endTimeQ := o.EndTime.String()
	if endTimeQ != "" {
		qs.Set("endTime", endTimeQ)
	}

	var hasSpecDiffIsQ string
	if o.HasSpecDiffIs != nil {
		hasSpecDiffIsQ = swag.FormatBool(*o.HasSpecDiffIs)
	}
	if hasSpecDiffIsQ != "" {
		qs.Set("hasSpecDiff[is]", hasSpecDiffIsQ)
	}

	var methodIsIR []string
	for _, methodIsI := range o.MethodIs {
		methodIsIS := methodIsI
		if methodIsIS != "" {
			methodIsIR = append(methodIsIR, methodIsIS)
		}
	}

	methodIs := swag.JoinByFormat(methodIsIR, "")

	if len(methodIs) > 0 {
		qsv := methodIs[0]
		if qsv != "" {
			qs.Set("method[is]", qsv)
		}
	}

	pageQ := swag.FormatInt64(o.Page)
	if pageQ != "" {
		qs.Set("page", pageQ)
	}

	pageSizeQ := swag.FormatInt64(o.PageSize)
	if pageSizeQ != "" {
		qs.Set("pageSize", pageSizeQ)
	}

	var pathContainsIR []string
	for _, pathContainsI := range o.PathContains {
		pathContainsIS := pathContainsI
		if pathContainsIS != "" {
			pathContainsIR = append(pathContainsIR, pathContainsIS)
		}
	}

	pathContains := swag.JoinByFormat(pathContainsIR, "")

	if len(pathContains) > 0 {
		qsv := pathContains[0]
		if qsv != "" {
			qs.Set("path[contains]", qsv)
		}
	}

	var pathEndQ string
	if o.PathEnd != nil {
		pathEndQ = *o.PathEnd
	}
	if pathEndQ != "" {
		qs.Set("path[end]", pathEndQ)
	}

	var pathIsNotIR []string
	for _, pathIsNotI := range o.PathIsNot {
		pathIsNotIS := pathIsNotI
		if pathIsNotIS != "" {
			pathIsNotIR = append(pathIsNotIR, pathIsNotIS)
		}
	}

	pathIsNot := swag.JoinByFormat(pathIsNotIR, "")

	if len(pathIsNot) > 0 {
		qsv := pathIsNot[0]
		if qsv != "" {
			qs.Set("path[isNot]", qsv)
		}
	}

	var pathIsIR []string
	for _, pathIsI := range o.PathIs {
		pathIsIS := pathIsI
		if pathIsIS != "" {
			pathIsIR = append(pathIsIR, pathIsIS)
		}
	}

	pathIs := swag.JoinByFormat(pathIsIR, "")

	if len(pathIs) > 0 {
		qsv := pathIs[0]
		if qsv != "" {
			qs.Set("path[is]", qsv)
		}
	}

	var pathStartQ string
	if o.PathStart != nil {
		pathStartQ = *o.PathStart
	}
	if pathStartQ != "" {
		qs.Set("path[start]", pathStartQ)
	}

	showNonAPIQ := swag.FormatBool(o.ShowNonAPI)
	if showNonAPIQ != "" {
		qs.Set("showNonApi", showNonAPIQ)
	}

	var sortDirQ string
	if o.SortDir != nil {
		sortDirQ = *o.SortDir
	}
	if sortDirQ != "" {
		qs.Set("sortDir", sortDirQ)
	}

	sortKeyQ := o.SortKey
	if sortKeyQ != "" {
		qs.Set("sortKey", sortKeyQ)
	}

	var sourceIPIsNotIR []string
	for _, sourceIPIsNotI := range o.SourceIPIsNot {
		sourceIPIsNotIS := sourceIPIsNotI
		if sourceIPIsNotIS != "" {
			sourceIPIsNotIR = append(sourceIPIsNotIR, sourceIPIsNotIS)
		}
	}

	sourceIPIsNot := swag.JoinByFormat(sourceIPIsNotIR, "")

	if len(sourceIPIsNot) > 0 {
		qsv := sourceIPIsNot[0]
		if qsv != "" {
			qs.Set("sourceIP[isNot]", qsv)
		}
	}

	var sourceIPIsIR []string
	for _, sourceIPIsI := range o.SourceIPIs {
		sourceIPIsIS := sourceIPIsI
		if sourceIPIsIS != "" {
			sourceIPIsIR = append(sourceIPIsIR, sourceIPIsIS)
		}
	}

	sourceIPIs := swag.JoinByFormat(sourceIPIsIR, "")

	if len(sourceIPIs) > 0 {
		qsv := sourceIPIs[0]
		if qsv != "" {
			qs.Set("sourceIP[is]", qsv)
		}
	}

	var sourceK8sObjectNameIsNotIR []string
	for _, sourceK8sObjectNameIsNotI := range o.SourceK8sObjectNameIsNot {
		sourceK8sObjectNameIsNotIS := sourceK8sObjectNameIsNotI
		if sourceK8sObjectNameIsNotIS != "" {
			sourceK8sObjectNameIsNotIR = append(sourceK8sObjectNameIsNotIR, sourceK8sObjectNameIsNotIS)
		}
	}

	sourceK8sObjectNameIsNot := swag.JoinByFormat(sourceK8sObjectNameIsNotIR, "")

	if len(sourceK8sObjectNameIsNot) > 0 {
		qsv := sourceK8sObjectNameIsNot[0]
		if qsv != "" {
			qs.Set("sourceK8sObject.name[isNot]", qsv)
		}
	}

	var sourceK8sObjectNameIsIR []string
	for _, sourceK8sObjectNameIsI := range o.SourceK8sObjectNameIs {
		sourceK8sObjectNameIsIS := sourceK8sObjectNameIsI
		if sourceK8sObjectNameIsIS != "" {
			sourceK8sObjectNameIsIR = append(sourceK8sObjectNameIsIR, sourceK8sObjectNameIsIS)
		}
	}

	sourceK8sObjectNameIs := swag.JoinByFormat(sourceK8sObjectNameIsIR, "")

	if len(sourceK8sObjectNameIs) > 0 {
		qsv := sourceK8sObjectNameIs[0]
		if qsv != "" {
			qs.Set("sourceK8sObject.name[is]", qsv)
		}
	}

	var specDiffTypeIsIR []string
	for _, specDiffTypeIsI := range o.SpecDiffTypeIs {
		specDiffTypeIsIS := specDiffTypeIsI
		if specDiffTypeIsIS != "" {
			specDiffTypeIsIR = append(specDiffTypeIsIR, specDiffTypeIsIS)
		}
	}

	specDiffTypeIs := swag.JoinByFormat(specDiffTypeIsIR, "")

	if len(specDiffTypeIs) > 0 {
		qsv := specDiffTypeIs[0]
		if qsv != "" {
			qs.Set("specDiffType[is]", qsv)
		}
	}

	var specContainsIR []string
	for _, specContainsI := range o.SpecContains {
		specContainsIS := specContainsI
		if specContainsIS != "" {
			specContainsIR = append(specContainsIR, specContainsIS)
		}
	}

	specContains := swag.JoinByFormat(specContainsIR, "")

	if len(specContains) > 0 {
		qsv := specContains[0]
		if qsv != "" {
			qs.Set("spec[contains]", qsv)
		}
	}

	var specEndQ string
	if o.SpecEnd != nil {
		specEndQ = *o.SpecEnd
	}
	if specEndQ != "" {
		qs.Set("spec[end]", specEndQ)
	}

	var specIsNotIR []string
	for _, specIsNotI := range o.SpecIsNot {
		specIsNotIS := specIsNotI
		if specIsNotIS != "" {
			specIsNotIR = append(specIsNotIR, specIsNotIS)
		}
	}

	specIsNot := swag.JoinByFormat(specIsNotIR, "")

	if len(specIsNot) > 0 {
		qsv := specIsNot[0]
		if qsv != "" {
			qs.Set("spec[isNot]", qsv)
		}
	}

	var specIsIR []string
	for _, specIsI := range o.SpecIs {
		specIsIS := specIsI
		if specIsIS != "" {
			specIsIR = append(specIsIR, specIsIS)
		}
	}

	specIs := swag.JoinByFormat(specIsIR, "")

	if len(specIs) > 0 {
		qsv := specIs[0]
		if qsv != "" {
			qs.Set("spec[is]", qsv)
		}
	}

	var specStartQ string
	if o.SpecStart != nil {
		specStartQ = *o.SpecStart
	}
	if specStartQ != "" {
		qs.Set("spec[start]", specStartQ)
	}

	startTimeQ := o.StartTime.String()
	if startTimeQ != "" {
		qs.Set("startTime", startTimeQ)
	}

	var statusCodeGteQ string
	if o.StatusCodeGte != nil {
		statusCodeGteQ = *o.StatusCodeGte
	}
	if statusCodeGteQ != "" {
		qs.Set("statusCode[gte]", statusCodeGteQ)
	}

	var statusCodeIsNotIR []string
	for _, statusCodeIsNotI := range o.StatusCodeIsNot {
		statusCodeIsNotIS := statusCodeIsNotI
		if statusCodeIsNotIS != "" {
			statusCodeIsNotIR = append(statusCodeIsNotIR, statusCodeIsNotIS)
		}
	}

	statusCodeIsNot := swag.JoinByFormat(statusCodeIsNotIR, "")

	if len(statusCodeIsNot) > 0 {
		qsv := statusCodeIsNot[0]
		if qsv != "" {
			qs.Set("statusCode[isNot]", qsv)
		}
	}

	var statusCodeIsIR []string
	for _, statusCodeIsI := range o.StatusCodeIs {
		statusCodeIsIS := statusCodeIsI
		if statusCodeIsIS != "" {
			statusCodeIsIR = append(statusCodeIsIR, statusCodeIsIS)
		}
	}

	statusCodeIs := swag.JoinByFormat(statusCodeIsIR, "")

	if len(statusCodeIs) > 0 {
		qsv := statusCodeIs[0]
		if qsv != "" {
			qs.Set("statusCode[is]", qsv)
		}
	}

	var statusCodeLteQ string
	if o.StatusCodeLte != nil {
		statusCodeLteQ = *o.StatusCodeLte
	}
	if statusCodeLteQ != "" {
		qs.Set("statusCode[lte]", statusCodeLteQ)
	}

	_result.RawQuery = qs.Encode()

	return &_result, nil
}

// Must is a helper function to panic when the url builder returns an error
func (o *GetAPIEventsURL) Must(u *url.URL, err error) *url.URL {
	if err != nil {
		panic(err)
	}
	if u == nil {
		panic("url can't be nil")
	}
	return u
}

// String returns the string representation of the path with query string
func (o *GetAPIEventsURL) String() string {
	return o.Must(o.Build()).String()
}

// BuildFull builds a full url with scheme, host, path and query string
func (o *GetAPIEventsURL) BuildFull(scheme, host string) (*url.URL, error) {
	if scheme == "" {
		return nil, errors.New("scheme is required for a full url on GetAPIEventsURL")
	}
	if host == "" {
		return nil, errors.New("host is required for a full url on GetAPIEventsURL")
	}

	base, err := o.Build()
	if err != nil {
		return nil, err
	}

	base.Scheme = scheme
	base.Host = host
	return base, nil
}

// StringFull returns the string representation of a complete url
func (o *GetAPIEventsURL) StringFull(scheme, host string) string {
	return o.Must(o.BuildFull(scheme, host)).String()
}
