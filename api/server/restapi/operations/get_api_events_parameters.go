// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetAPIEventsParams creates a new GetAPIEventsParams object
// with the default values initialized.
func NewGetAPIEventsParams() GetAPIEventsParams {

	var (
		// initialize parameters with default values

		sortDirDefault = string("ASC")
	)

	return GetAPIEventsParams{
		SortDir: &sortDirDefault,
	}
}

// GetAPIEventsParams contains all the bound params for the get API events operation
// typically these are obtained from a http.Request
//
// swagger:parameters GetAPIEvents
type GetAPIEventsParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*
	  In: query
	*/
	BflaStatusIsNot []string
	/*
	  In: query
	*/
	BflaStatusIs []string
	/*
	  In: query
	*/
	DestinationIPIsNot []string
	/*
	  In: query
	*/
	DestinationIPIs []string
	/*
	  In: query
	*/
	DestinationK8sObjectNameIsNot []string
	/*
	  In: query
	*/
	DestinationK8sObjectNameIs []string
	/*
	  In: query
	*/
	DestinationPortIsNot []string
	/*
	  In: query
	*/
	DestinationPortIs []string
	/*End time of the query
	  Required: true
	  In: query
	*/
	EndTime strfmt.DateTime
	/*
	  In: query
	*/
	HasSpecDiffIs *bool
	/*
	  In: query
	*/
	MethodIs []string
	/*Page number of the query
	  Required: true
	  In: query
	*/
	Page int64
	/*Maximum items to return
	  Required: true
	  Maximum: 50
	  Minimum: 1
	  In: query
	*/
	PageSize int64
	/*
	  In: query
	*/
	PathContains []string
	/*
	  In: query
	*/
	PathEnd *string
	/*
	  In: query
	*/
	PathIsNot []string
	/*
	  In: query
	*/
	PathIs []string
	/*
	  In: query
	*/
	PathStart *string
	/*
	  Required: true
	  In: query
	*/
	ShowNonAPI bool
	/*Sorting direction
	  In: query
	  Default: "ASC"
	*/
	SortDir *string
	/*Sort key
	  Required: true
	  In: query
	*/
	SortKey string
	/*
	  In: query
	*/
	SourceIPIsNot []string
	/*
	  In: query
	*/
	SourceIPIs []string
	/*
	  In: query
	*/
	SourceK8sObjectNameIsNot []string
	/*
	  In: query
	*/
	SourceK8sObjectNameIs []string
	/*
	  In: query
	*/
	SpecDiffTypeIs []string
	/*
	  In: query
	*/
	SpecContains []string
	/*
	  In: query
	*/
	SpecEnd *string
	/*
	  In: query
	*/
	SpecIsNot []string
	/*
	  In: query
	*/
	SpecIs []string
	/*
	  In: query
	*/
	SpecStart *string
	/*Start time of the query
	  Required: true
	  In: query
	*/
	StartTime strfmt.DateTime
	/*greater than or equal
	  In: query
	*/
	StatusCodeGte *string
	/*
	  In: query
	*/
	StatusCodeIsNot []string
	/*
	  In: query
	*/
	StatusCodeIs []string
	/*less than or equal
	  In: query
	*/
	StatusCodeLte *string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetAPIEventsParams() beforehand.
func (o *GetAPIEventsParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qBflaStatusIsNot, qhkBflaStatusIsNot, _ := qs.GetOK("bflaStatus[isNot]")
	if err := o.bindBflaStatusIsNot(qBflaStatusIsNot, qhkBflaStatusIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qBflaStatusIs, qhkBflaStatusIs, _ := qs.GetOK("bflaStatus[is]")
	if err := o.bindBflaStatusIs(qBflaStatusIs, qhkBflaStatusIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationIPIsNot, qhkDestinationIPIsNot, _ := qs.GetOK("destinationIP[isNot]")
	if err := o.bindDestinationIPIsNot(qDestinationIPIsNot, qhkDestinationIPIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationIPIs, qhkDestinationIPIs, _ := qs.GetOK("destinationIP[is]")
	if err := o.bindDestinationIPIs(qDestinationIPIs, qhkDestinationIPIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationK8sObjectNameIsNot, qhkDestinationK8sObjectNameIsNot, _ := qs.GetOK("destinationK8sObject.name[isNot]")
	if err := o.bindDestinationK8sObjectNameIsNot(qDestinationK8sObjectNameIsNot, qhkDestinationK8sObjectNameIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationK8sObjectNameIs, qhkDestinationK8sObjectNameIs, _ := qs.GetOK("destinationK8sObject.name[is]")
	if err := o.bindDestinationK8sObjectNameIs(qDestinationK8sObjectNameIs, qhkDestinationK8sObjectNameIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationPortIsNot, qhkDestinationPortIsNot, _ := qs.GetOK("destinationPort[isNot]")
	if err := o.bindDestinationPortIsNot(qDestinationPortIsNot, qhkDestinationPortIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qDestinationPortIs, qhkDestinationPortIs, _ := qs.GetOK("destinationPort[is]")
	if err := o.bindDestinationPortIs(qDestinationPortIs, qhkDestinationPortIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qEndTime, qhkEndTime, _ := qs.GetOK("endTime")
	if err := o.bindEndTime(qEndTime, qhkEndTime, route.Formats); err != nil {
		res = append(res, err)
	}

	qHasSpecDiffIs, qhkHasSpecDiffIs, _ := qs.GetOK("hasSpecDiff[is]")
	if err := o.bindHasSpecDiffIs(qHasSpecDiffIs, qhkHasSpecDiffIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qMethodIs, qhkMethodIs, _ := qs.GetOK("method[is]")
	if err := o.bindMethodIs(qMethodIs, qhkMethodIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qPage, qhkPage, _ := qs.GetOK("page")
	if err := o.bindPage(qPage, qhkPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPageSize, qhkPageSize, _ := qs.GetOK("pageSize")
	if err := o.bindPageSize(qPageSize, qhkPageSize, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathContains, qhkPathContains, _ := qs.GetOK("path[contains]")
	if err := o.bindPathContains(qPathContains, qhkPathContains, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathEnd, qhkPathEnd, _ := qs.GetOK("path[end]")
	if err := o.bindPathEnd(qPathEnd, qhkPathEnd, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathIsNot, qhkPathIsNot, _ := qs.GetOK("path[isNot]")
	if err := o.bindPathIsNot(qPathIsNot, qhkPathIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathIs, qhkPathIs, _ := qs.GetOK("path[is]")
	if err := o.bindPathIs(qPathIs, qhkPathIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qPathStart, qhkPathStart, _ := qs.GetOK("path[start]")
	if err := o.bindPathStart(qPathStart, qhkPathStart, route.Formats); err != nil {
		res = append(res, err)
	}

	qShowNonAPI, qhkShowNonAPI, _ := qs.GetOK("showNonApi")
	if err := o.bindShowNonAPI(qShowNonAPI, qhkShowNonAPI, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortDir, qhkSortDir, _ := qs.GetOK("sortDir")
	if err := o.bindSortDir(qSortDir, qhkSortDir, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortKey, qhkSortKey, _ := qs.GetOK("sortKey")
	if err := o.bindSortKey(qSortKey, qhkSortKey, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceIPIsNot, qhkSourceIPIsNot, _ := qs.GetOK("sourceIP[isNot]")
	if err := o.bindSourceIPIsNot(qSourceIPIsNot, qhkSourceIPIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceIPIs, qhkSourceIPIs, _ := qs.GetOK("sourceIP[is]")
	if err := o.bindSourceIPIs(qSourceIPIs, qhkSourceIPIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceK8sObjectNameIsNot, qhkSourceK8sObjectNameIsNot, _ := qs.GetOK("sourceK8sObject.name[isNot]")
	if err := o.bindSourceK8sObjectNameIsNot(qSourceK8sObjectNameIsNot, qhkSourceK8sObjectNameIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qSourceK8sObjectNameIs, qhkSourceK8sObjectNameIs, _ := qs.GetOK("sourceK8sObject.name[is]")
	if err := o.bindSourceK8sObjectNameIs(qSourceK8sObjectNameIs, qhkSourceK8sObjectNameIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecDiffTypeIs, qhkSpecDiffTypeIs, _ := qs.GetOK("specDiffType[is]")
	if err := o.bindSpecDiffTypeIs(qSpecDiffTypeIs, qhkSpecDiffTypeIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecContains, qhkSpecContains, _ := qs.GetOK("spec[contains]")
	if err := o.bindSpecContains(qSpecContains, qhkSpecContains, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecEnd, qhkSpecEnd, _ := qs.GetOK("spec[end]")
	if err := o.bindSpecEnd(qSpecEnd, qhkSpecEnd, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecIsNot, qhkSpecIsNot, _ := qs.GetOK("spec[isNot]")
	if err := o.bindSpecIsNot(qSpecIsNot, qhkSpecIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecIs, qhkSpecIs, _ := qs.GetOK("spec[is]")
	if err := o.bindSpecIs(qSpecIs, qhkSpecIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSpecStart, qhkSpecStart, _ := qs.GetOK("spec[start]")
	if err := o.bindSpecStart(qSpecStart, qhkSpecStart, route.Formats); err != nil {
		res = append(res, err)
	}

	qStartTime, qhkStartTime, _ := qs.GetOK("startTime")
	if err := o.bindStartTime(qStartTime, qhkStartTime, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeGte, qhkStatusCodeGte, _ := qs.GetOK("statusCode[gte]")
	if err := o.bindStatusCodeGte(qStatusCodeGte, qhkStatusCodeGte, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeIsNot, qhkStatusCodeIsNot, _ := qs.GetOK("statusCode[isNot]")
	if err := o.bindStatusCodeIsNot(qStatusCodeIsNot, qhkStatusCodeIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeIs, qhkStatusCodeIs, _ := qs.GetOK("statusCode[is]")
	if err := o.bindStatusCodeIs(qStatusCodeIs, qhkStatusCodeIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qStatusCodeLte, qhkStatusCodeLte, _ := qs.GetOK("statusCode[lte]")
	if err := o.bindStatusCodeLte(qStatusCodeLte, qhkStatusCodeLte, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindBflaStatusIsNot binds and validates array parameter BflaStatusIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindBflaStatusIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvBflaStatusIsNot string
	if len(rawData) > 0 {
		qvBflaStatusIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	bflaStatusIsNotIC := swag.SplitByFormat(qvBflaStatusIsNot, "")
	if len(bflaStatusIsNotIC) == 0 {
		return nil
	}

	var bflaStatusIsNotIR []string
	for _, bflaStatusIsNotIV := range bflaStatusIsNotIC {
		bflaStatusIsNotI := bflaStatusIsNotIV

		bflaStatusIsNotIR = append(bflaStatusIsNotIR, bflaStatusIsNotI)
	}

	o.BflaStatusIsNot = bflaStatusIsNotIR

	return nil
}

// bindBflaStatusIs binds and validates array parameter BflaStatusIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindBflaStatusIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvBflaStatusIs string
	if len(rawData) > 0 {
		qvBflaStatusIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	bflaStatusIsIC := swag.SplitByFormat(qvBflaStatusIs, "")
	if len(bflaStatusIsIC) == 0 {
		return nil
	}

	var bflaStatusIsIR []string
	for _, bflaStatusIsIV := range bflaStatusIsIC {
		bflaStatusIsI := bflaStatusIsIV

		bflaStatusIsIR = append(bflaStatusIsIR, bflaStatusIsI)
	}

	o.BflaStatusIs = bflaStatusIsIR

	return nil
}

// bindDestinationIPIsNot binds and validates array parameter DestinationIPIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationIPIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationIPIsNot string
	if len(rawData) > 0 {
		qvDestinationIPIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationIPIsNotIC := swag.SplitByFormat(qvDestinationIPIsNot, "")
	if len(destinationIPIsNotIC) == 0 {
		return nil
	}

	var destinationIPIsNotIR []string
	for _, destinationIPIsNotIV := range destinationIPIsNotIC {
		destinationIPIsNotI := destinationIPIsNotIV

		destinationIPIsNotIR = append(destinationIPIsNotIR, destinationIPIsNotI)
	}

	o.DestinationIPIsNot = destinationIPIsNotIR

	return nil
}

// bindDestinationIPIs binds and validates array parameter DestinationIPIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationIPIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationIPIs string
	if len(rawData) > 0 {
		qvDestinationIPIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationIPIsIC := swag.SplitByFormat(qvDestinationIPIs, "")
	if len(destinationIPIsIC) == 0 {
		return nil
	}

	var destinationIPIsIR []string
	for _, destinationIPIsIV := range destinationIPIsIC {
		destinationIPIsI := destinationIPIsIV

		destinationIPIsIR = append(destinationIPIsIR, destinationIPIsI)
	}

	o.DestinationIPIs = destinationIPIsIR

	return nil
}

// bindDestinationK8sObjectNameIsNot binds and validates array parameter DestinationK8sObjectNameIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationK8sObjectNameIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationK8sObjectNameIsNot string
	if len(rawData) > 0 {
		qvDestinationK8sObjectNameIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationK8sObjectNameIsNotIC := swag.SplitByFormat(qvDestinationK8sObjectNameIsNot, "")
	if len(destinationK8sObjectNameIsNotIC) == 0 {
		return nil
	}

	var destinationK8sObjectNameIsNotIR []string
	for _, destinationK8sObjectNameIsNotIV := range destinationK8sObjectNameIsNotIC {
		destinationK8sObjectNameIsNotI := destinationK8sObjectNameIsNotIV

		destinationK8sObjectNameIsNotIR = append(destinationK8sObjectNameIsNotIR, destinationK8sObjectNameIsNotI)
	}

	o.DestinationK8sObjectNameIsNot = destinationK8sObjectNameIsNotIR

	return nil
}

// bindDestinationK8sObjectNameIs binds and validates array parameter DestinationK8sObjectNameIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationK8sObjectNameIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationK8sObjectNameIs string
	if len(rawData) > 0 {
		qvDestinationK8sObjectNameIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationK8sObjectNameIsIC := swag.SplitByFormat(qvDestinationK8sObjectNameIs, "")
	if len(destinationK8sObjectNameIsIC) == 0 {
		return nil
	}

	var destinationK8sObjectNameIsIR []string
	for _, destinationK8sObjectNameIsIV := range destinationK8sObjectNameIsIC {
		destinationK8sObjectNameIsI := destinationK8sObjectNameIsIV

		destinationK8sObjectNameIsIR = append(destinationK8sObjectNameIsIR, destinationK8sObjectNameIsI)
	}

	o.DestinationK8sObjectNameIs = destinationK8sObjectNameIsIR

	return nil
}

// bindDestinationPortIsNot binds and validates array parameter DestinationPortIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationPortIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationPortIsNot string
	if len(rawData) > 0 {
		qvDestinationPortIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationPortIsNotIC := swag.SplitByFormat(qvDestinationPortIsNot, "")
	if len(destinationPortIsNotIC) == 0 {
		return nil
	}

	var destinationPortIsNotIR []string
	for _, destinationPortIsNotIV := range destinationPortIsNotIC {
		destinationPortIsNotI := destinationPortIsNotIV

		destinationPortIsNotIR = append(destinationPortIsNotIR, destinationPortIsNotI)
	}

	o.DestinationPortIsNot = destinationPortIsNotIR

	return nil
}

// bindDestinationPortIs binds and validates array parameter DestinationPortIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindDestinationPortIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvDestinationPortIs string
	if len(rawData) > 0 {
		qvDestinationPortIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	destinationPortIsIC := swag.SplitByFormat(qvDestinationPortIs, "")
	if len(destinationPortIsIC) == 0 {
		return nil
	}

	var destinationPortIsIR []string
	for _, destinationPortIsIV := range destinationPortIsIC {
		destinationPortIsI := destinationPortIsIV

		destinationPortIsIR = append(destinationPortIsIR, destinationPortIsI)
	}

	o.DestinationPortIs = destinationPortIsIR

	return nil
}

// bindEndTime binds and validates parameter EndTime from query.
func (o *GetAPIEventsParams) bindEndTime(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("endTime", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("endTime", "query", raw); err != nil {
		return err
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("endTime", "query", "strfmt.DateTime", raw)
	}
	o.EndTime = *(value.(*strfmt.DateTime))

	if err := o.validateEndTime(formats); err != nil {
		return err
	}

	return nil
}

// validateEndTime carries on validations for parameter EndTime
func (o *GetAPIEventsParams) validateEndTime(formats strfmt.Registry) error {

	if err := validate.FormatOf("endTime", "query", "date-time", o.EndTime.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindHasSpecDiffIs binds and validates parameter HasSpecDiffIs from query.
func (o *GetAPIEventsParams) bindHasSpecDiffIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("hasSpecDiff[is]", "query", "bool", raw)
	}
	o.HasSpecDiffIs = &value

	return nil
}

// bindMethodIs binds and validates array parameter MethodIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindMethodIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvMethodIs string
	if len(rawData) > 0 {
		qvMethodIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	methodIsIC := swag.SplitByFormat(qvMethodIs, "")
	if len(methodIsIC) == 0 {
		return nil
	}

	var methodIsIR []string
	for i, methodIsIV := range methodIsIC {
		methodIsI := methodIsIV

		if err := validate.EnumCase(fmt.Sprintf("%s.%v", "method[is]", i), "query", methodIsI, []interface{}{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"}, true); err != nil {
			return err
		}

		methodIsIR = append(methodIsIR, methodIsI)
	}

	o.MethodIs = methodIsIR

	return nil
}

// bindPage binds and validates parameter Page from query.
func (o *GetAPIEventsParams) bindPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("page", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("page", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page", "query", "int64", raw)
	}
	o.Page = value

	return nil
}

// bindPageSize binds and validates parameter PageSize from query.
func (o *GetAPIEventsParams) bindPageSize(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("pageSize", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("pageSize", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("pageSize", "query", "int64", raw)
	}
	o.PageSize = value

	if err := o.validatePageSize(formats); err != nil {
		return err
	}

	return nil
}

// validatePageSize carries on validations for parameter PageSize
func (o *GetAPIEventsParams) validatePageSize(formats strfmt.Registry) error {

	if err := validate.MinimumInt("pageSize", "query", o.PageSize, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("pageSize", "query", o.PageSize, 50, false); err != nil {
		return err
	}

	return nil
}

// bindPathContains binds and validates array parameter PathContains from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindPathContains(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathContains string
	if len(rawData) > 0 {
		qvPathContains = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathContainsIC := swag.SplitByFormat(qvPathContains, "")
	if len(pathContainsIC) == 0 {
		return nil
	}

	var pathContainsIR []string
	for _, pathContainsIV := range pathContainsIC {
		pathContainsI := pathContainsIV

		pathContainsIR = append(pathContainsIR, pathContainsI)
	}

	o.PathContains = pathContainsIR

	return nil
}

// bindPathEnd binds and validates parameter PathEnd from query.
func (o *GetAPIEventsParams) bindPathEnd(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PathEnd = &raw

	return nil
}

// bindPathIsNot binds and validates array parameter PathIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindPathIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathIsNot string
	if len(rawData) > 0 {
		qvPathIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathIsNotIC := swag.SplitByFormat(qvPathIsNot, "")
	if len(pathIsNotIC) == 0 {
		return nil
	}

	var pathIsNotIR []string
	for _, pathIsNotIV := range pathIsNotIC {
		pathIsNotI := pathIsNotIV

		pathIsNotIR = append(pathIsNotIR, pathIsNotI)
	}

	o.PathIsNot = pathIsNotIR

	return nil
}

// bindPathIs binds and validates array parameter PathIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindPathIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPathIs string
	if len(rawData) > 0 {
		qvPathIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	pathIsIC := swag.SplitByFormat(qvPathIs, "")
	if len(pathIsIC) == 0 {
		return nil
	}

	var pathIsIR []string
	for _, pathIsIV := range pathIsIC {
		pathIsI := pathIsIV

		pathIsIR = append(pathIsIR, pathIsI)
	}

	o.PathIs = pathIsIR

	return nil
}

// bindPathStart binds and validates parameter PathStart from query.
func (o *GetAPIEventsParams) bindPathStart(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.PathStart = &raw

	return nil
}

// bindShowNonAPI binds and validates parameter ShowNonAPI from query.
func (o *GetAPIEventsParams) bindShowNonAPI(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("showNonApi", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("showNonApi", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("showNonApi", "query", "bool", raw)
	}
	o.ShowNonAPI = value

	return nil
}

// bindSortDir binds and validates parameter SortDir from query.
func (o *GetAPIEventsParams) bindSortDir(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetAPIEventsParams()
		return nil
	}
	o.SortDir = &raw

	if err := o.validateSortDir(formats); err != nil {
		return err
	}

	return nil
}

// validateSortDir carries on validations for parameter SortDir
func (o *GetAPIEventsParams) validateSortDir(formats strfmt.Registry) error {

	if err := validate.EnumCase("sortDir", "query", *o.SortDir, []interface{}{"ASC", "DESC"}, true); err != nil {
		return err
	}

	return nil
}

// bindSortKey binds and validates parameter SortKey from query.
func (o *GetAPIEventsParams) bindSortKey(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("sortKey", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("sortKey", "query", raw); err != nil {
		return err
	}
	o.SortKey = raw

	if err := o.validateSortKey(formats); err != nil {
		return err
	}

	return nil
}

// validateSortKey carries on validations for parameter SortKey
func (o *GetAPIEventsParams) validateSortKey(formats strfmt.Registry) error {

	if err := validate.EnumCase("sortKey", "query", o.SortKey, []interface{}{"time", "method", "path", "statusCode", "sourceIP", "destinationIP", "destinationPort", "specDiffType", "hostSpecName", "apiType"}, true); err != nil {
		return err
	}

	return nil
}

// bindSourceIPIsNot binds and validates array parameter SourceIPIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSourceIPIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceIPIsNot string
	if len(rawData) > 0 {
		qvSourceIPIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceIPIsNotIC := swag.SplitByFormat(qvSourceIPIsNot, "")
	if len(sourceIPIsNotIC) == 0 {
		return nil
	}

	var sourceIPIsNotIR []string
	for _, sourceIPIsNotIV := range sourceIPIsNotIC {
		sourceIPIsNotI := sourceIPIsNotIV

		sourceIPIsNotIR = append(sourceIPIsNotIR, sourceIPIsNotI)
	}

	o.SourceIPIsNot = sourceIPIsNotIR

	return nil
}

// bindSourceIPIs binds and validates array parameter SourceIPIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSourceIPIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceIPIs string
	if len(rawData) > 0 {
		qvSourceIPIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceIPIsIC := swag.SplitByFormat(qvSourceIPIs, "")
	if len(sourceIPIsIC) == 0 {
		return nil
	}

	var sourceIPIsIR []string
	for _, sourceIPIsIV := range sourceIPIsIC {
		sourceIPIsI := sourceIPIsIV

		sourceIPIsIR = append(sourceIPIsIR, sourceIPIsI)
	}

	o.SourceIPIs = sourceIPIsIR

	return nil
}

// bindSourceK8sObjectNameIsNot binds and validates array parameter SourceK8sObjectNameIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSourceK8sObjectNameIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceK8sObjectNameIsNot string
	if len(rawData) > 0 {
		qvSourceK8sObjectNameIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceK8sObjectNameIsNotIC := swag.SplitByFormat(qvSourceK8sObjectNameIsNot, "")
	if len(sourceK8sObjectNameIsNotIC) == 0 {
		return nil
	}

	var sourceK8sObjectNameIsNotIR []string
	for _, sourceK8sObjectNameIsNotIV := range sourceK8sObjectNameIsNotIC {
		sourceK8sObjectNameIsNotI := sourceK8sObjectNameIsNotIV

		sourceK8sObjectNameIsNotIR = append(sourceK8sObjectNameIsNotIR, sourceK8sObjectNameIsNotI)
	}

	o.SourceK8sObjectNameIsNot = sourceK8sObjectNameIsNotIR

	return nil
}

// bindSourceK8sObjectNameIs binds and validates array parameter SourceK8sObjectNameIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSourceK8sObjectNameIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSourceK8sObjectNameIs string
	if len(rawData) > 0 {
		qvSourceK8sObjectNameIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	sourceK8sObjectNameIsIC := swag.SplitByFormat(qvSourceK8sObjectNameIs, "")
	if len(sourceK8sObjectNameIsIC) == 0 {
		return nil
	}

	var sourceK8sObjectNameIsIR []string
	for _, sourceK8sObjectNameIsIV := range sourceK8sObjectNameIsIC {
		sourceK8sObjectNameIsI := sourceK8sObjectNameIsIV

		sourceK8sObjectNameIsIR = append(sourceK8sObjectNameIsIR, sourceK8sObjectNameIsI)
	}

	o.SourceK8sObjectNameIs = sourceK8sObjectNameIsIR

	return nil
}

// bindSpecDiffTypeIs binds and validates array parameter SpecDiffTypeIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSpecDiffTypeIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecDiffTypeIs string
	if len(rawData) > 0 {
		qvSpecDiffTypeIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specDiffTypeIsIC := swag.SplitByFormat(qvSpecDiffTypeIs, "")
	if len(specDiffTypeIsIC) == 0 {
		return nil
	}

	var specDiffTypeIsIR []string
	for i, specDiffTypeIsIV := range specDiffTypeIsIC {
		specDiffTypeIsI := specDiffTypeIsIV

		if err := validate.EnumCase(fmt.Sprintf("%s.%v", "specDiffType[is]", i), "query", specDiffTypeIsI, []interface{}{"ZOMBIE_DIFF", "SHADOW_DIFF", "GENERAL_DIFF", "NO_DIFF"}, true); err != nil {
			return err
		}

		specDiffTypeIsIR = append(specDiffTypeIsIR, specDiffTypeIsI)
	}

	o.SpecDiffTypeIs = specDiffTypeIsIR

	return nil
}

// bindSpecContains binds and validates array parameter SpecContains from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSpecContains(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecContains string
	if len(rawData) > 0 {
		qvSpecContains = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specContainsIC := swag.SplitByFormat(qvSpecContains, "")
	if len(specContainsIC) == 0 {
		return nil
	}

	var specContainsIR []string
	for _, specContainsIV := range specContainsIC {
		specContainsI := specContainsIV

		specContainsIR = append(specContainsIR, specContainsI)
	}

	o.SpecContains = specContainsIR

	return nil
}

// bindSpecEnd binds and validates parameter SpecEnd from query.
func (o *GetAPIEventsParams) bindSpecEnd(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.SpecEnd = &raw

	return nil
}

// bindSpecIsNot binds and validates array parameter SpecIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSpecIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecIsNot string
	if len(rawData) > 0 {
		qvSpecIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specIsNotIC := swag.SplitByFormat(qvSpecIsNot, "")
	if len(specIsNotIC) == 0 {
		return nil
	}

	var specIsNotIR []string
	for _, specIsNotIV := range specIsNotIC {
		specIsNotI := specIsNotIV

		specIsNotIR = append(specIsNotIR, specIsNotI)
	}

	o.SpecIsNot = specIsNotIR

	return nil
}

// bindSpecIs binds and validates array parameter SpecIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindSpecIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvSpecIs string
	if len(rawData) > 0 {
		qvSpecIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	specIsIC := swag.SplitByFormat(qvSpecIs, "")
	if len(specIsIC) == 0 {
		return nil
	}

	var specIsIR []string
	for _, specIsIV := range specIsIC {
		specIsI := specIsIV

		specIsIR = append(specIsIR, specIsI)
	}

	o.SpecIs = specIsIR

	return nil
}

// bindSpecStart binds and validates parameter SpecStart from query.
func (o *GetAPIEventsParams) bindSpecStart(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.SpecStart = &raw

	return nil
}

// bindStartTime binds and validates parameter StartTime from query.
func (o *GetAPIEventsParams) bindStartTime(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("startTime", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("startTime", "query", raw); err != nil {
		return err
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("startTime", "query", "strfmt.DateTime", raw)
	}
	o.StartTime = *(value.(*strfmt.DateTime))

	if err := o.validateStartTime(formats); err != nil {
		return err
	}

	return nil
}

// validateStartTime carries on validations for parameter StartTime
func (o *GetAPIEventsParams) validateStartTime(formats strfmt.Registry) error {

	if err := validate.FormatOf("startTime", "query", "date-time", o.StartTime.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindStatusCodeGte binds and validates parameter StatusCodeGte from query.
func (o *GetAPIEventsParams) bindStatusCodeGte(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.StatusCodeGte = &raw

	return nil
}

// bindStatusCodeIsNot binds and validates array parameter StatusCodeIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindStatusCodeIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvStatusCodeIsNot string
	if len(rawData) > 0 {
		qvStatusCodeIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	statusCodeIsNotIC := swag.SplitByFormat(qvStatusCodeIsNot, "")
	if len(statusCodeIsNotIC) == 0 {
		return nil
	}

	var statusCodeIsNotIR []string
	for _, statusCodeIsNotIV := range statusCodeIsNotIC {
		statusCodeIsNotI := statusCodeIsNotIV

		statusCodeIsNotIR = append(statusCodeIsNotIR, statusCodeIsNotI)
	}

	o.StatusCodeIsNot = statusCodeIsNotIR

	return nil
}

// bindStatusCodeIs binds and validates array parameter StatusCodeIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIEventsParams) bindStatusCodeIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvStatusCodeIs string
	if len(rawData) > 0 {
		qvStatusCodeIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	statusCodeIsIC := swag.SplitByFormat(qvStatusCodeIs, "")
	if len(statusCodeIsIC) == 0 {
		return nil
	}

	var statusCodeIsIR []string
	for _, statusCodeIsIV := range statusCodeIsIC {
		statusCodeIsI := statusCodeIsIV

		statusCodeIsIR = append(statusCodeIsIR, statusCodeIsI)
	}

	o.StatusCodeIs = statusCodeIsIR

	return nil
}

// bindStatusCodeLte binds and validates parameter StatusCodeLte from query.
func (o *GetAPIEventsParams) bindStatusCodeLte(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.StatusCodeLte = &raw

	return nil
}
